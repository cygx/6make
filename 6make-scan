#!/usr/bin/env perl6

my $start = BEGIN now;

use nqp;

sub log-start($info) {
    print "    $info...", (' ' x (20 - $info.chars));
    $start //= now;
}

sub log-end {
    my $end = now;
    printf "[ %5.2fs ]\n", $end - $start;
    $start = Nil;
}

log-start 'script startup';
log-end;

LEAVE $*CWD = INIT $*CWD;
$*CWD = $*SIXMAKE-DIR // $?FILE.IO.parent.abspath;

my &find := EVALFILE('6make-find.plugin');

class PM {
    has $.name;
    has $.repo;
    has $.path;
    has @.deps;
}

my @builtins = <v6 nqp MONKEY-TYPING Test NativeCall NQPHLL>;

log-start 'reading repo.list';
my @repos = 'repo.list'.IO.lines.map({ [ .comb(/\H+/) ] });
log-end;

log-start 'finding modules';
my @libdirs = @repos.map({ "{.[0]}/lib" });
my @modules = find(:noerr, :f, :name<*.pm *.pm6>, @libdirs);
log-end;

log-start 'parsing modules';
my %registry = @modules.map: -> $pm {
    my ($repo, $path) = $pm.split('/lib/', 2);
    my $name = $path.subst(/\.pm6?$/, '').subst(:g, '/', '::');

    my @deps;
    my $fh := nqp::open(nqp::unbox_s($pm), 'r');
    repeat until nqp::eoffh($fh) {
        $_ := nqp::readlinefh($fh);
        if (not .starts-with('=begin pod') ff .starts-with('=end pod'))
            && /^\h*[use|need]\h+([\w+]+ % '::')/ {
            my $dep := ~$0;
            @deps.push($dep) unless $dep ~~ any @builtins;
        }
    }

    $name => PM.new(:$name, :$repo, :$path, :@deps);
}
log-end;

log-start 'writing Makefile';
my @missing;
'Makefile'.IO.spurt: qq:to/__END__/;
COMPILE = perl6 -Iblib --target=mbc --output=\$@ \$<
PULL    = git -C \$(patsubst pull-%,%,\$@) pull
CLONE   = git clone \$(URL) \$@

REPOS := \$(wildcard { @repos>>.[0].join(' ') })
BC := { %registry.values>>.path.map({ "blib/$_.moarvm" }).join(' ') }

bc: \$(BC)
\$(BC):
\t@mkdir -p \$(dir \$@)
\t\$(COMPILE)

pull: \$(REPOS:\%=pull-%)
\$(REPOS:\%=pull-%):
\t\$(PULL)

clean:; rm -rf blib

scan:; ./6make-scan

6: scan
\t@\$(MAKE) --no-print-directory bc

{
    join "\n", do for @repos -> [ $name, $url ] {
        "$name: URL = $url",
        "$name:; \$(CLONE)\n";
    }
}
{
    join "\n", do for %registry.values {
        my $pm = $_;
        my $deps = .deps ?? .deps.map({
            if %registry{$_} {
                "blib/{%registry{$_}.path}.moarvm";
            }
            else {
                @missing.push($($_, $pm.name));
                '';
            }
        }).join(' ') !! '';

        "blib/{.path}.moarvm: blib/\%.moarvm: {.repo}/lib/% $deps";
    }
}
__END__
log-end;

if @missing {
    print "\n";
    note "missing dependency {.[0]} for {.[1]}" for @missing;
    print "\n";
    exit 1;
}
