#!/usr/bin/env perl6

LEAVE $*CWD = INIT $*CWD;
$*CWD = $*SIXMAKE-DIR // $?FILE.IO.parent.abspath;

my &find := EVALFILE('6make-find.plugin');

class PM {
    has $.name;
    has $.repo;
    has $.path;
    has @.deps;
}

my @builtins = <v6 nqp MONKEY-TYPING Test NativeCall NQPHLL>;

say '...reading repo.list';
my @repos = 'repo.list'.IO.lines.map({ [ .split(/\h+/, 2) ] });

say '...looking for modules';
my $files = @repos.map(*.[0])
    . grep({ "$_/lib".IO.d })
    . map: { |find(:f, "$_/lib", <*.pm *.pm6>) }

say '...parsing modules';
my %registry = @$files.race.map: {
    my ($repo, $path) = .split('/lib/', 2);
    my $name = $path.subst(/\.pm6?$/, '').subst(:g, '/', '::');
    my $deps = .IO.lines.map({
        when /^\h*[use|need]\h+([\w+]+ % '::')/ { ~$0 }
        default { Empty }
    }).grep(none @builtins);

    $name => PM.new(:$name, :$repo, :$path, :$deps);
}

say '...writing Makefile';
'Makefile'.IO.spurt: qq:to/__END__/;
COMPILE = perl6 -Iblib --target=mbc --output=\$@ \$<
PULL    = git -C \$(patsubst pull-%,%,\$@) pull
CLONE   = git clone \$(URL) \$@

REPOS := \$(wildcard { @repos>>.[0].join(' ') })
BC := { %registry.values>>.path.map({ "blib/$_.moarvm" }).join(' ') }

bc: \$(BC)
\$(BC):
\t@mkdir -p \$(dir \$@)
\t\$(COMPILE)

pull: \$(REPOS:\%=pull-%)
\$(REPOS:\%=pull-%):
\t\$(PULL)

upgrade: pull
\t./6make-scan
\t@\$(MAKE) --no-print-directory bc

clean:; rm -rf blib

6:; ./6make-scan

{
    join "\n", do for @repos -> [ $name, $url ] {
        "$name: URL = $url",
        "$name:; \$(CLONE)\n";
    }
}
{
    join "\n", do for %registry.values {
        my $pm = $_;
        my $deps = .deps ?? .deps.map({
            if %registry{$_} {
                "blib/{%registry{$_}.path}.moarvm";
            }
            else {
                note "missing dependency $_ for {$pm.name}";
                '';
            }
        }).join(' ') !! '';

        "blib/{.path}.moarvm: blib/\%.moarvm: {.repo}/lib/% $deps";
    }
}
__END__

say 'done.';
